## var let const 区别

1. var 
在ES5中，顶层对象的属性和全局变量是等价的，用var声明的变量既是全局变量，也是顶层变量。
注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。
在函数中用var声明的变量的作用域是函数局部的。

2. let 
用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效，不存在变量提升。
同一个作用域下不能重复声明。
let具有块级作用域，声明只在该作用域内有效。
下面的代码中，var声明的是全局变量，全程都在发生值的改变。而let声明的i的只在本轮循环有效。
```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10

var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6

```

for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
```
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量。
```


3. const
const声明一个只读常量，一旦声明，常量的值就不能改变。
const实际上保证的，并不是变量的值不得改动，而是变量指向的内存地址所保存的数据不得改动。对简单类型来说，值就保存在变量指向的内存地址，因此等同于常量。对于复合型数据来说，变量保存的内存地址是一个指向实际数据的指针，const只能保证这个指针式固定的，即总指向另一个固定的地址。


#### 区别 
* 变量提升
* 暂时性死区
* 块级作用域
* 重复声明
* 修改声明的变量
* 使用

1. 变量提升
var声明存在变量提升，即变量可以在声明前调用，值为undefined.
因为创建阶段会在代码中扫描变量和函数的声明，然后将函数声明存在环境中。但是变量用var声明会被初始化为undefined，用const和let声明的保持uninitialized。

ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量。

2. 暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的
let和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。其实就是 uninitialized 状态。
如果区块中有let和const命令，这个区块对这些命令声明声明变量，从一开始就形成了封闭作用域，凡是在声明之前就使用这些变量就会报错。
```
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

3. 块级作用域
var 不存在块级作用域
let const存在
3.1 为什么会出现块级作用域？
ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
1:内层变量可能会覆盖外层变量。
```
var tmp = new Date();
function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined  内层变量存在变量提升，导致内层的tmp变量覆盖了外层的tmp变量。
```
2: 用来计数的循环变量泄露为全局变量。
```
var s = 'hello';
for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}
console.log(i); // 5
```

3.2 ES6 的块级作用域
let为js新增了块级作用域
```
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
// 外层代码块不受内层代码块的影响。
```


4. 重复声明
var允许重复声明变量
let和const在同一作用域不允许重复声明变量

5. 修改声明的变量
var和let可以
const声明一个只读的常量。一旦声明，常量的值就不能改变







