## JS内存

### 内存空间
JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。

栈： 后进先出，像羽毛球桶。最先放进入的羽毛球，总是要等前面的都取出来以后才能取出。
堆：是一种树状结构，像书架。只要知道书名，就可以直接取出来书。
队列：先进先出，排队做核酸。也是事件循环的基础结构。

####  变量的存放
1. 基本类型：保存在栈中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。
2. 引用类型：保存在堆中，因为这种值的大小不固定，所以不能保存在栈中。内存地址大小是固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时，先从栈读取内存地址，然后通过地址找到堆中的值。
```
var a = 20;
var b = a;
b = 30;
console.log(a) // 20  b只是复制了a的值，a和b有个字独立的栈空间

var a = { name: '前端开发' }
var b = a;
b.name = '进阶';
console.log(a.name) // 进阶 a b的栈中的引用指向了同一个内存空间

var a = { name: '前端开发' }
var b = a;
a = null;
console.log(b)  // { name: '前端开发' }  这里对a进行重新赋予了简单类型的值，没有影响到b

```

#### 内存空间管理
js的内存声明周期是：
1、分配你所需要的内存
2、使用分配到的内存（读、写）
3、不需要时将其释放、归还

### 内存回收
JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。

* 局部变量和全局变量的销毁：
局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。
全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。

* 以Google的V8引擎为例，V8引擎中所有的JS对象都是通过堆来进行内存分配的
初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。

* V8引擎对堆内存中的JS对象进行分代管理
新生代：存活周期较短的JS对象，如临时变量、字符串等。
老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

### 垃圾回收算法
1. 标记清除（常用）
当变量进入执行环境时，就标记这个变量为“进入环境”。进入环境的变量所占的内存就不能被释放，当变量离开环境时候，就被标记为“离开环境”。

1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；

2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。

3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。

```
email.message = document.createElement(“div”);
displayList.appendChild(email.message);

// 稍后从displayList中清除DOM元素
displayList.removeAllChildren();
```

2. 引用计数
引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。

引用计数有一个致命的问题，那就是循环引用:
如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。

